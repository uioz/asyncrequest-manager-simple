# 简介

**注意**:该项目还在测试中(未完成).
**注意**:个人项目不保证稳定性.

这是一个Node模块.

这个项目是一个简单的页面爬虫框架,虽然我称之为`框架`但是实际上也就算是个小工具,能够将简单的页面爬取`动作`进行切割管理.

简单的来说他使用策略模式将一次或者多次爬取一个固定的任务视为一种策略(一个函数).

该模块可以将多个策略进行组合并提供一些常见的页面爬取需求的支持.

- 不依赖请求模块 - 这部分由你决定
- 不依赖node - 内部没有使用任何node模块
- 内部执行均是异步
- 策略函数递归
- 策略函数并发
- 备选策略支持
- 请求配置式
- 十分少量的代码?(大概吧)

## 这个想法是怎么来的

假设有这么一个链接`www.xxx.com`这是一个门户网站,在网站的左侧有一个热门搜索排行榜.

我们想爬取该排行榜然后获取里面的内容然后组成一个数据结构返回,这一次的任务就完成了,我希望该数据格式如下:
```
{
    'xxx':'xxxx',
    'xxx':'xxxx'
}
```
键是热门搜索的标题,而值就是对应链接中的正文.

也就是说我们有两个步骤:
1. 获取首页中的所有由热门搜索构成的键
2. 获取对应键中链接中的正文

没错实际上每个步骤就是一个策略,而这些策略是可以进行组合的,你可以想的到一个列表中前后顺序的组合.

实际上我们只有两个问题:
1. 策略函数之间的通信
2. 最后结果挂载的位置

没错本模块就是围绕这这个功能的实现还提供了一系列的周边功能.

## 策略函数的约定

说到请求资源在node中肯定是异步的这点毫无疑问,所以一个策略函数一定要返回一个Promise.

你可以使用ES7中的`async`来定义一个异步函数来简化代码.

现在我们来定义这个策略函数用于实现上面提到的第一个功能:(伪代码)
```
async function fun1() {

    const request = require('request');

    const result = request('www.xxx.com');
    // result = ['xxx','xx','xxx'...] 文章标题

}
```

问题来了我们该如何进行`交互`呢?很简单把值返回就可以了,这里的返回值要求返回一个`对象`,这个对象会传递给下一个函数:(伪代码)
```
async function fun1() {

    const request = require('request');

    const result = request('www.xxx.com');
    // result = ['xxx','xx','xxx'...] 文章标题

    let a = {};

    for (const key of result) {

        a[key] = '';

    }

    return a;

}
```

定义第二个策略函数获取内容,在这个函数的第一个参数中有一个`arguments`属性就是上一个函数的返回值:(伪代码)
```
async function fun2(handle) {

    let keys = Object.keys(handle.arguments);

    const request = require('request');

    const result = request('www.xxx.com',keys);
    // result = {'xxx':'xxxx','xx':'xxxx'...}

}

```
遇到第二个问题了如何返回内容,这个模块中肯定有一个外包裹,我们将获取到的结果进行返回?

很简单策略函数的第一个参数还提供了一个钩子参数`getResult`他返回一个对象而这个对象就是我们最终返回的结果,我们只需要将结果挂载在这个对象上就可以了:
```
async function fun2(handle) {

    let keys = Object.keys(handle.arguments);

    const request = require('request');

    const result = request('www.xxx.com',keys);
    // result = {'xxx':'xxxx','xx':'xxxx'...}

    handle.getResult().result = result;
}
```

**总结**:在getResult返回的对象上挂载属性是最终我们模块返回的结果(虽然还没有讲API),`return`返回的内容会被挂载在下一个策略函数参数的`arguments`属性上.

### 简单约定

- 策略函数必须要有返回值,当前的返回值就是下一个策略函数的参数对象,如果没有参数就返回一个空对象,如果下一个策略函数还需要当前的参数那么就将当前的参数对象返回.

## 更多钩子更多特性

在详解他到底api长啥样之前我想给你介绍他的所有钩子,也就是第一个参数中的所有你需要知道的内容.

可能你也猜到了后续的参数中也会有其他的东西,是的第二个参数中也有其他东西,但是没有第一个重要.

我们先来看看第一个参数中的定义:
```
interface StragegyHandle {
    /**
     * 上个策略组传入的参数
     */
    arguments: object;
    /**
     * 要求停止进行递归的钩子
     * 
     * 拥有该钩子意味着当前执行已经进入了递归模式.
     * 调用该钩子则停止递归.
     * 此时return(async)或者resolve(Promise)的值将交由下一个策略函数
     */
    stopRecursion: (() => void)|false;
    /**
     * 要求当前策略函数进行递归调用.
     * 
     * reutrn(async)或者resolve(Promise)返回的值将会传入下一次自己的递归调用中.
     * 在递归过程调用该函数无效.
     */
    recursion: () => void;
    /**
     * 要求下一个策略函数进行并发
     * 
     * return(async)或者resolve(Promise)的时候提供一个数组.
     * 数组的长度会被当做下一个策略函数的并发数量而数组的每一个内容都会被当做一个参数传入到对应的并发函数钩子的参数中.
     */
    concurrency: () => void;
    /**
     * 调用该函数后则会停止这个策略函数,返回的结果也会抛弃.
     * 
     * 如果调用该方法的策略函数挂载的策略图上tryError属性为true则不会报错.
     * 会跳过这个策略函数,并且执行他的替代任务图如果有的话.
     * 
     * - 参数
     *   - message 抛出错误的信息,默认信息Custom Error
     */
    fail:(message:string)=>void;
    /**
     * 获取作为结果的对象,可以为其挂载任何属性
     * 
     * **注意**:一旦调用recursion或concurrency或fail钩子后就只会返回false
     */
    getResult:()=>object|false;
    /**
     * 设置一个结果会覆盖原有的结果
     */
    setResult:(data:any)=>void;
}
```

这里有两个特殊的钩子函数:
- recursion 调用该钩子就会递归这个策略函数`自身`直到在调用stopRecursion钩子
- concurrency 调用该钩子就会让`下一个`策略函数并发

我想上面的注释已经足够详细了,不过还有些额外的补充:
- arguments 在策略函数中不建议对该属性修改,因为这没有什么太大的意义.
- stopRecursion 只有进入了递归模式后这个钩子才会出现
- recursion 进入递归模式后再去调用这个钩子是没有作用的(你想做什么?),如果你想让后续的策略函数进行递归,应该让下一个策略函数来调用这个钩子.
- concurrency 这个钩子是让`下一个`策略函数并发的多次调用也是无效的,不过已经身处并发模式的策略函数在调用该钩子会让下一个策略函数也并发,**注意**:在并发过程中会有多个策略函数执行但是如果其中任何一个报错或者调用了`fail`钩子那么整个任务都会当做失败.
- fail 无论什么时候这都是你最后的选项,一但调用参数钩子上的所有内容都会被锁住,无论什么模式下的返回值都会抛弃,调用他意味着你放弃了本次的请求.
- getResult 没有什么好说的
- setResult 使用一个新的内容替换模块内部的结果对象


**注意**:并发模式不建议返回内容可以返回空对象,或者将数据挂载在getResult返回的对象上,如果你执意要返回也是可以不过我这里提供一下合并的算法:
```
Object.assign({}, ...resultCollection);// resultCollection中保存着所有并发请求返回的结果
```
**注意**:在策略函数中执行错误或者手动抛出一个错误和调用`fail`钩子基本是等价的.

## 配置式

## 备选模式

## 快速请求模式